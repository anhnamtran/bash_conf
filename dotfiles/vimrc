set nocompatible              " be iMproved, required
set encoding=utf-8
filetype off                  " required

" set the runtime path to include Vundle and initialize
call plug#begin('~/.vim/bundle')
" alternatively, pass a path where Vundle should install plugins
"call vundle#begin('~/some/path/here')

" Plugins

" Themes and GUIs
Plug 'joshdick/onedark.vim'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'airblade/vim-gitgutter'
Plug 'majutsushi/tagbar'

" Syntax handling
Plug 'octol/vim-cpp-enhanced-highlight'
Plug 'sheerun/vim-polyglot'
Plug 'neoclide/coc.nvim', {'branch': 'release'}


" System navigation
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'
Plug 'christoomey/vim-tmux-navigator'
Plug 'preservim/nerdtree'
Plug 'Xuyuanp/nerdtree-git-plugin'

" Session tracking
Plug 'tpope/vim-obsession'

" Utility
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-commentary'
Plug 'szw/vim-maximizer'
Plug 'inkarkat/vim-mark'
Plug 'inkarkat/vim-ingo-library'
Plug 'jiangmiao/auto-pairs'

" Browser plugin
Plug 'glacambre/firenvim', { 'do': { _ -> firenvim#install(0) } }

" Vimwiki
Plug 'vimwiki/vimwiki'

" All of your Plugins must be added before the following line
call plug#end()            " required
filetype plugin indent on    " required
" To ignore plugin indent changes, instead use:
"filetype plugin on
"
" Brief help
" :PluginList       - lists configured plugins
" :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate
" :PluginSearch foo - searches for foo; append `!` to refresh local cache
" :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal
"
" see :h vundle for more details or wiki for FAQ
" Put your non-Plugin stuff after this line
"--------------------end Vundle setup

" -------------------------------- SETTINGS -----------------------------------
" View `man` pages and add new file types
runtime ftplugin/man.vim

" Obsession
nnoremap <F10> :Obsession<CR>
nnoremap <C-F10> :Obsession!<CR>

" Firenvim Configs
let g:firenvim_config = { 
    \ 'globalSettings': {
        \ 'alt': 'all',
    \  },
    \ 'localSettings': {
        \ '.*': {
            \ 'cmdline': 'neovim',
            \ 'content': 'text',
            \ 'priority': 0,
            \ 'selector': 'textarea',
            \ 'takeover': 'always',
        \ },
    \ }
\ }

let g:dont_write = v:false
function! My_Write(timer) abort
	let g:dont_write = v:false
	write
endfunction

function! Delay_My_Write() abort
	if g:dont_write
		return
	end
	let g:dont_write = v:true
	call timer_start(10000, 'My_Write')
endfunction

au TextChanged * ++nested call Delay_My_Write()
au TextChangedI * ++nested call Delay_My_Write()" Dirvish

" Airline
let g:airline_theme='onedark'
let g:airline_highlighting_cache=1
let g:airline#extensions#tabline#show_tabs = 1
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#show_tab_type = 0
let g:airline#extensions#tabline#show_tab_count = 0
let g:airline#extensions#tabline#show_close_button = 0
let g:airline#extensions#tabline#formatter = 'short_path'

" Add window numbers to the status line
if !exists("window_numbers_added")
   let window_numbers_added = 1
   function! WindowNumber(...)
       let builder = a:1
       let context = a:2
       call builder.add_section('airline_b', '[%{tabpagewinnr(tabpagenr())}]')
       return 0
   endfunction

   call airline#add_statusline_func('WindowNumber')
   call airline#add_inactive_statusline_func('WindowNumber')
endif

" Add current function name to the status line
let g:airline#extensions#tagbar#enabled = 1

" Enhanced CPP highligh options
let g:cpp_class_scope_highlight = 1
let g:cpp_member_variable_highlight = 1
let g:cpp_class_decl_highlight = 1

" Python highlighting options
let g:python_highlight_class_vars = 1
let g:python_highlight_func_calls = 1
let g:python_highlight_string_formatting = 1
let g:python_highlight_string_format = 1
let g:python_highlight_exceptions = 1

" NERDTree
let g:NERDTreeSortHiddenFirst = 1
let g:NERDTreeQuitOnOpen = 1

" coc.nvim

autocmd CursorHold * silent call CocActionAsync('highlight')
hi! link CocHighlightText Underlined

" tagbar
let g:tagbar_autoclose = 1
let g:tagbar_position = 'bottom'
let g:tagbar_height = 30
nnoremap <silent> <F9> :TagbarToggle<CR>

" update time
set updatetime=100

" Indent lines

set conceallevel=1

" Fugitive and GitGutter
" And diff options
set diffopt=filler,context:5
set foldopen-=search

" line numbers
set number
" Don't show keys pressed
set noshowcmd

" split windows to the right instead
set splitright
set equalalways

" wrapping
set wrap linebreak nolist

" tabbing
if !exists("loaded_arista_vim")
  set tabstop=2
  set shiftwidth=2
  set expandtab
endif

" search highlighting
set hlsearch
nnoremap <silent> <Space> :nohlsearch<Bar>:echo<CR>

" indenting
set autoindent
set smarttab

" updates file automatically
set autoread

" Triger `autoread` when files changes on disk
" https://unix.stackexchange.com/questions/149209/refresh-changed-content-of-file-opened-in-vim/383044#383044
" https://vi.stackexchange.com/questions/13692/prevent-focusgained-autocmd-running-in-command-line-editing-mode
autocmd FocusGained,BufEnter *
   \ if mode() != 'c' | checktime | endif
" Notification after file change
" https://vi.stackexchange.com/questions/13091/autocmd-event-for-autoread
autocmd FileChangedShellPost *
  \ echohl WarningMsg | echo "Buffer reloaded." | echohl None

" taking care of files with long lines
" this gives vim a seizure if there are too many long lines
set display+=lastline

" use mouse with tmux
set mouse=a

" enables local vimrc files
set exrc
set secure

" enables modeline
set modeline

" Set the timeout between mapped sequences and key codes
set timeoutlen=200
set ttimeoutlen=100

" Enable smart case searching
set ignorecase
set smartcase

" Make line numbers relative to current position
augroup WinRelNum
   autocmd WinEnter * set relativenumber
   autocmd WinLeave * set norelativenumber
   autocmd BufWinEnter <buffer>  set relativenumber
augroup END

" make grep use ripgrep instead
set grepprg=rg\ --vimgrep
set grepformat^=%f:%l:%c:%m

" --------------------------------- KEYMAPS -----------------------------------
"-------------------------------- INSERT MODE----------------------------------
" Ctrl-S to save
inoremap <c-s> <c-o>:w<CR>

" Replacing `esc` in insert mode
inoremap jj <ESC>
inoremap qq <ESC>:x<CR>

" quickly edit the previous typo
inoremap <C-l> <c-g>u<Esc>[s1z=`]a<c-g>u

"---------------------------------- NORMAL MODE -------------------------------
nnoremap <CR> o<Esc>
augroup CRFix
   autocmd CmdwinEnter * nnoremap <CR> <CR>
   autocmd BufReadPost quickfix nnoremap <CR> <CR>
augroup END

" Ctrl+S to save
nnoremap <c-s> :w<CR><x><u>

" Tabs
nnoremap tl :tabn<CR>
nnoremap th :tabp<CR>
nnoremap tc :tabc<CR>

" Buffers
nnoremap H :bp<CR>
nnoremap L :bn<CR>
nnoremap <leader>q :bp <BAR> bd #<CR>
nnoremap <leader>ls :ls<CR>

" Remove trailing white spaces
nnoremap <silent> <F5> :let _s=@/ <Bar> :%s/\s\+$//e <Bar> :let @/=_s <Bar> :nohl <Bar> :unlet _s <CR><C-o>

" Change current window's directory to current file's
nnoremap <leader>cd :lcd %:p:h<CR>

" FZF bindings. Requires fzf.vim
" Opens FZF in the current directory
nnoremap _ :FZF %:p:h<CR>

nnoremap <leader>b :Buffers<CR>
nnoremap <leader>l :BLines<CR>

nnoremap <leader>rn :set relativenumber<CR>
nnoremap <leader>rN :set relativenumber!<CR>

 let g:fzf_layout = { 'window': { 'width': 0.9, 'height': 0.6 } }

nnoremap <C-w>; :wincmd p<CR>

function! BlinkCursorLine()
   for i in range(3)
      set nocursorline
      redraw
      sleep 100m
      set cursorline
      redraw
   endfor
endfunction
nnoremap bl :call BlinkCursorLine()<CR>

nnoremap <C-w>z :MaximizerToggle<CR>

" NERDTree specific
nnoremap <C-n>n :NERDTreeToggle<CR>
nnoremap - :NERDTree %<CR>

"--------------------------------- TERM MODE ----------------------------------

tnoremap <Esc> <C-\><C-N>
tnoremap <C-h> <C-\><C-N><C-w>h
tnoremap <C-j> <C-\><C-N><C-w>j
tnoremap <C-k> <C-\><C-N><C-w>k
tnoremap <C-l> <C-\><C-N><C-w>l

"------------------------------- EXTRA COMMANDS -------------------------------
command -nargs=+ Grip !grip --quiet <args> &

" automatically opens the quickfix and location windows on specific
" quick fix commands
command -nargs=+ Make make <args> | cwindow
command -nargs=+ Grep grep <args> | cwindow
command -nargs=+ Vim vim <args> | cwindow

" Turn a buffer into a scratch buffer
command Scratch setlocal buftype=nofile bufhidden=hide noswapfile nobuflisted
" show all highlight groups
command HighLights source $VIMRUNTIME/syntax/hitest.vim

"------------------------------ EXTRA FUNCTIONS -------------------------------
function! HandleURL()
  let s:uri = matchstr(getline("."), '[a-z]*:\/\/[^ >,;]*')
  echo s:uri
  if s:uri != ""
    silent exec "!open '".s:uri."'"
  else
    echo "No URI found in line."
  endif
endfunction
map gx :call HandleURL()<cr>

function! DeleteInactiveBufs()
    "From tabpagebuflist() help, get a list of all buffers in all tabs
    let tablist = []
    for i in range(tabpagenr('$'))
        call extend(tablist, tabpagebuflist(i + 1))
    endfor

    "Below originally inspired by Hara Krishna Dara and Keith Roberts
    "http://tech.groups.yahoo.com/group/vim/message/56425
    let nWipeouts = 0
    for i in range(1, bufnr('$'))
        if bufexists(i) && !getbufvar(i,"&mod") && index(tablist, i) == -1
        "bufno exists AND isn't modified AND isn't in the list of buffers open in windows and tabs
            silent exec 'bwipeout' i
            let nWipeouts = nWipeouts + 1
        endif
    endfor
    echomsg nWipeouts . ' buffer(s) wiped out'
endfunction
command! OpenOnly :call DeleteInactiveBufs()
nnoremap <C-w>b :OpenOnly<CR>

"-------------------------------- THEMES AND GUI ------------------------------

" Columns limits
" highlights the current line
set cursorline

" themes
" 24-bit colors
if &term =~ '256color'
  " disable Background Color Erase (BCE)
  set t_ut=
endif

if !has('nvim')
  set ttymouse=xterm2
endif

if has('termguicolors')
  set termguicolors
endif

syntax on

let g:onedark_color_overrides = {
  \ "cursor_grey": { "gui": "#3E4452", "cterm": "237", "cterm16": "8" }
\}

" Highlight trailing white spaces
augroup ExtraWhiteSpaceHi
  au!
  match DiffDelete /\s\+$/
  autocmd BufWinEnter * match DiffDelete /\s\+$/
  autocmd InsertEnter * match DiffDelete /\s\+\%#\@<!$/
  autocmd InsertLeave * match DiffDelete /\s\+$/
  autocmd BufWinLeave * call clearmatches()
augroup END

augroup ActiveWin
  au!
  autocmd WinEnter * set colorcolumn=85
  autocmd WinLeave * set colorcolumn=0
augroup END

" onedark.vim override: Don't set a background color when running in a terminal;
if (has("autocmd") && !has("gui_running"))
  augroup colorset
    autocmd!
    let s:white = { "gui": "#ABB2BF", "cterm": "145", "cterm16" : "7" }
    autocmd ColorScheme * call onedark#set_highlight("Normal", { "fg": s:white })
  augroup END
endif

set background=dark
colorscheme onedark
