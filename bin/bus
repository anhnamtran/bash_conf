#!/bin/bash
SUB_CMD_HELP="""
  shell: ssh into the home bus. Can be interactive and not.
  mosh: mosh into the home bus. Interactive only
  create: create a new home bus
  delete: delete an existing home bus
  status: view the status of the home bus
  update: update the home bus
  run: run arbitrary b5 commands
  jobs: show the list of jobs that have been run on a bus
"""
# Argument parsing generated using argbash
#
# ARG_POSITIONAL_SINGLE([command],[one of the valid commands])
# ARG_TYPE_GROUP_SET([command],[COMMAND],[command],[shell,mosh,create,delete,status,update,run,jobs])
# ARG_DEFAULTS_POS([])
# ARG_POSITIONAL_DOUBLEDASH([])
# ARG_LEFTOVERS([any subcommand for either b5 or shell, ignored otherwise])
# ARG_HELP([Interact with home buses more easily],[$SUB_CMD_HELP])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.dev for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}

# validators

command()
{
	local _allowed=("shell" "mosh" "create" "delete" "status" "update" "run" "jobs") _seeking="$1"
	for element in "${_allowed[@]}"
	do
		test "$element" = "$_seeking" && echo "$element" && return 0
	done
	die "Value '$_seeking' (of argument '$2') doesn't match the list of allowed values: 'shell', 'mosh', 'create', 'delete', 'status', 'update', 'run' and 'jobs'" 4
}


begins_with_short_option()
{
	local first_option all_short_options='h'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_command=
_arg_leftovers=()
# THE DEFAULTS INITIALIZATION - OPTIONALS


print_help()
{
	printf '%s\n' "Interact with home buses more easily"
	printf 'Usage: %s [-h|--help] [--] <command> ... \n' "$0"
	printf '\t%s\n' "<command>: one of the valid commands. Can be one of: 'shell', 'mosh', 'create', 'delete', 'status', 'update', 'run' and 'jobs'"
	printf '\t%s\n' "... : any subcommand for either b5 or shell, ignored otherwise"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\n%s\n' "$SUB_CMD_HELP"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		if test "$_key" = '--'
		then
			shift
			test $# -gt 0 || break
			_positionals+=("$@")
			_positionals_count=$((_positionals_count + $#))
			shift $(($# - 1))
			_last_positional="$1"
			break
		fi
		case "$_key" in
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'command'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_command "
	_our_args=$((${#_positionals[@]} - 1))
	for ((ii = 0; ii < _our_args; ii++))
	do
		_positional_names="$_positional_names _arg_leftovers[$((ii + 0))]"
	done

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash
# Validation of values
_arg_command="$(command "$_arg_command" "command")" || exit 1


### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


# Needed because of a b5 bug
export LC_ALL=en_US.UTF-8
BUS="bus:home"

check_b5() {
  if ! which b5 &>/dev/null; then
    die 'b5 not installed, most bus operations will not work. Run the following to install the portable version:\ncurl -fS "https://barney-api.infra.corp.arista.io/download/client?system=$(uname -s | tr A-Z a-z)&arch=$(uname -m | sed -e s/x86_64/amd64/ -e s/aarch64/arm64/)" > b5 && chmod 755 b5'
  fi
}

bus_run() {
  b5 bus "$@"
}

bus_status() {
  local status=$(bus_run show --by-nickname home 2>/dev/null | jq ".status" | sed -e 's/"//g')
  case "$status" in
    Ready|Pending)
      if [[ "$status" == "Ready" ]]; then
        # Could be updating if an update job is in the job list
        local update_finished=$(bus_run jobs --by-nickname home --output-format=json 2>/dev/null \
                                | jq '.[] | select(.["job type"] == "update" and .status == "Complete")')
        if [[ -z "$update_finished" ]]; then
          status="Updating"
        fi
      fi
      echo "$status"
      ;;
    "")
      echo "Deleted"
      ;;
    null)
      echo "Pending"
      ;;
  esac
}

_bus_state() {
  local state="$1"
  local waited="off"
  local frames=(
    "Waiting for bus to be ${state}.  "
    "Waiting for bus to be ${state}.. "
    "Waiting for bus to be ${state}..."
  )
  local frame=0
  while [[ "$(bus_status)" =~ "$state" ]]; do
    echo -en "${frames[$frame]}\r"
    ((frame < ${#frames[@]})) && frame=$((frame + 1)) || frame=0
    waited="on"
    sleep 1
  done
  [[ "$waited" = "on" ]] && echo " Done!"
}

_update_ssh_config() {
  local ssh_conf=/etc/ssh/ssh_config.d/002-arista-bus-ssh.conf

  _bus_state "Ready"
  echo "Downloading ssh config to $ssh_conf"
  sudo curl -o "$ssh_conf" "https://barney-bbm.infra.corp.arista.io/bus/${USER}/ssh-config?global-config=true&delimiter=:"
}

bus_shell() {
  _bus_state "Ready|Updating"
  ssh "$BUS" "$*"
}

bus_mosh() {
  _bus_state "Ready|Updating"
  mosh --experimental-remote-ip=remote "$BUS"
}

bus_create() {
  bus_run create --nickname home --topic home --image "code.arista.io/infra/home-bus%bus/eos"
  _update_ssh_config
}

bus_delete() {
  bus_run delete --force --by-nickname home
  _bus_state "Deleted"
}

bus_update() {
  _bus_state "Ready"
  bus_run update --by-nickname home
}

bus_jobs() {
  _bus_state "Ready|Updating"
  bus_run jobs --by-nickname home
}


bus_$_arg_command "${_arg_leftovers[@]}"

#  <-- neded because of Argbash
# ] <-- needed because of Argbash
